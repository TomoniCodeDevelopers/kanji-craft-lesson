<!doctype html>
<html lang="ja">

<head>
  <meta charset="utf-8" />
  <title>GLB → Preview & STL (Three.js, 同一姿勢/スケールで出力)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --side: 320px;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif;
      display: grid;
      grid-template-columns: var(--side) 1fr;
      /* ← aside幅を考慮し、残りが main */
      height: 100%;
      background: #f7f7f7;
    }

    aside {
      padding: 16px;
      border-right: 1px solid #ddd;
      overflow: auto;
    }

    main {
      position: relative;
      background: #fff;
    }

    #viewport {
      position: absolute;
      inset: 0;
      display: block;
    }

    /* ← mainいっぱいに広げる */

    fieldset {
      border: 1px solid #ccc;
      margin: 8px 0;
      padding: 10px;
    }

    legend {
      font-weight: 600;
    }

    label {
      display: block;
      margin: 6px 0 2px;
    }

    button {
      width: 100%;
      padding: 10px;
      margin-top: 8px;
    }

    small {
      color: #666;
    }

    .hint {
      font-size: 12px;
      color: #555;
    }
  </style>

  <!-- Three.js import map -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.164.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.164.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>
  <aside>
    <h2>GLB → STL（同一姿勢で出力）</h2>
    <fieldset>
      <legend>.glb 読み込み</legend>
      <input id="glbFile" type="file" accept=".glb" />
      <small class="hint">※ ファイル選択で自動読み込み・プレビューします（X-90°回転・縮小適用）。</small>
    </fieldset>

    <button id="export">STLを書き出し</button>
    <div class="sep"></div>
    <small id="stats"></small>
  </aside>

  <main>
    <canvas id="viewport"></canvas>
  </main>

  <script type="module">
    /***** Libraries *****/
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { STLExporter } from 'three/addons/exporters/STLExporter.js';
    import { mergeGeometries, mergeVertices } from 'three/addons/utils/BufferGeometryUtils.js';

    /***** 読み込み時補正（プレビュー=出力に同一反映） *****/
    const LOAD_ROTATE_X90 = true;  // X軸に -90°
    const LOAD_SCALE = 0.5;   // 読み込み縮小倍率（必要に応じて調整）

    /***** UI *****/
    const glbFileEl = document.getElementById('glbFile');
    const exportBtn = document.getElementById('export');
    const statsEl = document.getElementById('stats');

    /***** Three.js 基本セットアップ *****/
    const canvas = document.getElementById('viewport');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.NoToneMapping;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#e5e5e5');

    const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 200000);
    camera.position.set(3, 2.5, 3);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.screenSpacePanning = false;

    // 初期ライト
    const dir1 = new THREE.DirectionalLight(0xffffff, 1.0);
    dir1.position.set(4, 6, 4);
    dir1.castShadow = true;
    dir1.shadow.mapSize.set(2048, 2048);
    dir1.shadow.camera.near = 0.1;
    dir1.shadow.camera.far = 2000;
    dir1.shadow.camera.left = -100;
    dir1.shadow.camera.right = 100;
    dir1.shadow.camera.top = 100;
    dir1.shadow.camera.bottom = -100;
    scene.add(dir1);

    const dir2 = new THREE.DirectionalLight(0xffffff, 0.4);
    dir2.position.set(-6, 3, -4);
    scene.add(dir2);

    scene.add(new THREE.AmbientLight(0xf0f0f0, 0.25));

    // グリッド＆影受け床（★動的に作り直すので、まずはダミーを作成）
    let grid = new THREE.GridHelper(50, 50, 0x777777, 0xbbbbbb);
    grid.position.y = 0;
    scene.add(grid);

    let shadowPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(200, 200),
      new THREE.ShadowMaterial({ opacity: 0.22 })
    );
    shadowPlane.rotation.x = -Math.PI / 2;
    shadowPlane.position.y = 0;
    shadowPlane.receiveShadow = true;
    scene.add(shadowPlane);

    // GLB グループ
    let meshGroup = new THREE.Group();
    scene.add(meshGroup);

    /***** レイアウト完全追従：ResizeObserverで main サイズに合わせてキャンバスを埋める *****/
    const mainEl = document.querySelector('main');
    const ro = new ResizeObserver(() => resize());
    ro.observe(mainEl);

    function resize() {
      const rect = mainEl.getBoundingClientRect(); // ← aside含めた残り領域の実寸
      const ratio = Math.min(window.devicePixelRatio || 1, 2);
      renderer.setPixelRatio(ratio);
      renderer.setSize(rect.width, rect.height, false);
      camera.aspect = rect.width / rect.height;
      camera.updateProjectionMatrix();
    }
    resize(); // 初期

    (function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    })();

    /***** 動的フレーミング（グリッド/床サイズもモデルに合わせて再生成） *****/
    function niceRound(v) {
      // メジャーな表示サイズに丸め（1,2,5のスケール）
      const p = Math.pow(10, Math.floor(Math.log10(v)));
      const d = v / p;
      if (d < 1.5) return 1 * p;
      if (d < 3.5) return 2 * p;
      if (d < 7.5) return 5 * p;
      return 10 * p;
    }

    function rebuildGround(sizeHint) {
      // 目安: モデルの最大サイズの 2〜3倍の正方形グリッド
      const gridSize = niceRound(sizeHint * 2.2);
      const divisions = Math.max(10, Math.min(200, Math.round(gridSize))); // 密度は控えめに

      // 既存を入れ替え
      scene.remove(grid);
      grid.geometry.dispose();
      grid.material.dispose();
      grid = new THREE.GridHelper(gridSize, divisions, 0x666666, 0xaaaaaa);
      scene.add(grid);

      scene.remove(shadowPlane);
      shadowPlane.geometry.dispose();
      shadowPlane.material.dispose();
      shadowPlane = new THREE.Mesh(
        new THREE.PlaneGeometry(gridSize * 2, gridSize * 2),
        new THREE.ShadowMaterial({ opacity: 0.22 })
      );
      shadowPlane.rotation.x = -Math.PI / 2;
      shadowPlane.receiveShadow = true;
      scene.add(shadowPlane);
    }

    function frameToObject(object, padding = 1.2) {
      const box = new THREE.Box3().setFromObject(object);
      if (!isFinite(box.min.x) || !isFinite(box.max.x)) return;

      const size = new THREE.Vector3(); box.getSize(size);
      const center = new THREE.Vector3(); box.getCenter(center);

      // グリッド/床のサイズをモデルに合わせて再生成
      const maxSize = Math.max(size.x, size.y, size.z);
      rebuildGround(maxSize);

      // カメラ距離算出：バウンディング・スフィア基準
      const sphere = new THREE.Sphere(); box.getBoundingSphere(sphere);
      const radius = sphere.radius * padding;
      const fov = THREE.MathUtils.degToRad(camera.fov);
      // 画面縦方向に合わせる（アスペクトも加味）
      const dist = radius / Math.sin(fov / 2);

      controls.target.copy(center);

      // 斜め上から見下ろす位置に移動
      const camOffset = new THREE.Vector3(1, 0.75, 1).normalize().multiplyScalar(dist);
      camera.position.copy(center).add(camOffset);

      camera.near = Math.max(0.01, dist / 1000);
      camera.far = Math.max(2000, dist * 10);
      camera.updateProjectionMatrix();

      // グリッド/床の高さをモデル底面に追従
      shadowPlane.position.y = box.min.y;
      grid.position.y = box.min.y + 0.001;

      // コントロールの距離制限（極端なズームを抑制）
      controls.minDistance = radius * 0.2;
      controls.maxDistance = radius * 10;
    }

    /***** 情報表示 *****/
    function updateStats(object) {
      const box = new THREE.Box3().setFromObject(object);
      const size = new THREE.Vector3(); box.getSize(size);
      statsEl.textContent = `推定サイズ: ${size.x.toFixed(3)} × ${size.y.toFixed(3)} × ${size.z.toFixed(3)} / 読み込みスケール: ${LOAD_SCALE}`;
    }

    /***** エッジ線（軽い輪郭強調） *****/
    function addEdgesRecursively(root, deg = 20, color = 0x444444) {
      const edgeMtl = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.6 });
      root.traverse(obj => {
        if (!obj.isMesh || !obj.geometry) return;
        if (obj.userData.__edgeLine) {
          obj.remove(obj.userData.__edgeLine);
          obj.userData.__edgeLine.geometry.dispose();
          obj.userData.__edgeLine.material.dispose();
          obj.userData.__edgeLine = null;
        }
        const eg = new THREE.EdgesGeometry(obj.geometry, deg);
        const line = new THREE.LineSegments(eg, edgeMtl);
        line.userData.isEdgeLine = true;
        obj.add(line);
        obj.userData.__edgeLine = line;
        obj.castShadow = true;
        obj.receiveShadow = true;
      });
    }

    /***** GLB 読み込み（ファイル選択で自動） *****/
    const loader = new GLTFLoader();

    glbFileEl?.addEventListener('change', () => {
      const f = glbFileEl?.files?.[0];
      if (!f) return;
      const url = URL.createObjectURL(f);

      loader.load(url, (gltf) => {
        URL.revokeObjectURL(url);

        // 既存をクリア
        meshGroup.clear();

        // 読み込んだシーン
        const root = gltf.scene;

        // 読み込み時補正（プレビュー＝出力 共通）
        if (LOAD_ROTATE_X90) root.rotateX(-Math.PI / 2);
        if (Number.isFinite(LOAD_SCALE) && LOAD_SCALE > 0) {
          root.scale.setScalar(LOAD_SCALE);
        }

        meshGroup.add(root);

        // GLB材質のまま・輪郭線
        addEdgesRecursively(meshGroup, 20, 0x444444);

        // フレーミング・統計
        frameToObject(meshGroup, 1.25);
        updateStats(meshGroup);

      }, undefined, (err) => {
        URL.revokeObjectURL(url);
        console.error(err);
        alert('GLB の読み込みに失敗しました。コンソールをご確認ください。');
      });
    });

    /***** STL 出力（プレビューと完全同一姿勢・スケールを適用） *****/
    function exportSTL() {
      if (meshGroup.children.length === 0) {
        alert('先に GLB を読み込んでください。');
        return;
      }

      const geoms = [];
      meshGroup.updateMatrixWorld(true);

      const tmpObjMatrix = new THREE.Matrix4();
      const tmpInstMatrix = new THREE.Matrix4();

      meshGroup.traverse(obj => {
        if (obj.isMesh && !obj.isInstancedMesh && obj.geometry) {
          const g = obj.geometry.clone();
          g.applyMatrix4(obj.matrixWorld);
          geoms.push(g);
        } else if (obj.isInstancedMesh && obj.geometry) {
          const count = obj.count;
          for (let i = 0; i < count; i++) {
            obj.getMatrixAt(i, tmpInstMatrix);
            const g = obj.geometry.clone();
            tmpObjMatrix.copy(obj.matrixWorld).multiply(tmpInstMatrix);
            g.applyMatrix4(tmpObjMatrix);
            geoms.push(g);
          }
        }
      });

      if (geoms.length === 0) {
        alert('エクスポート対象のメッシュが見つかりません。');
        return;
      }

      // 結合
      let merged = mergeGeometries(geoms, false);

      // === STL専用オフセット（プレビューは変えずSTLだけ調整したいときに使用） ===
      const EXPORT_OFFSET = new THREE.Matrix4();
      EXPORT_OFFSET.multiply(new THREE.Matrix4().makeRotationX(+Math.PI / 2));
      merged.applyMatrix4(EXPORT_OFFSET);

      // 溶接してSTL出力
      merged = mergeVertices(merged, 1e-6);
      const exporter = new STLExporter();
      const stl = exporter.parse(new THREE.Mesh(merged), { binary: true });

      const blob = new Blob([stl], { type: 'model/stl' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'export_from_glb.stl';
      a.click();
      URL.revokeObjectURL(a.href);
    }

    exportBtn.addEventListener('click', () => {
      try { exportSTL(); } catch (e) { console.error(e); alert('STL 書き出しに失敗しました。'); }
    });
  </script>
</body>

</html>
